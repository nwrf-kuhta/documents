# 第2章 データを学ぶ

## 2.1 データの種類

| データ型 | 説明 |
| --- | --- |
| Null型 | 存在しないオブジェクトを表す。<br>オブジェクトが存在しないことを明示的に表すために使用する。<br>Null型の値はnullだけである。 |
| Undefined型 | 未定義の値を表す。<br>初期化されていないデータはこのUndefined型の値を持つ。<br>意図的にUndefined型の値を使用する場合にはundefinedを使用する。 |
| 真偽値型 | 条件が成り立つか、成り立たないかを表す。<br>真偽値型の値はtrueとfalseの2つだけである。 |
| 数値型 | 有限の小数を表す。<br>JavaScriptで数値を表現するには主にこちらを使用する。<br>表現できる値の範囲が限られている。 |
| 長整数型 | 上下限のない数値型を表す。 |
| 文字列型 | 文字列、つまり文字の並びを表す。 |
| シンボル型 | 同じ値を複数作り出すことができない一意の値を表す。<br>基本的にはシステムによって生成され、一般の開発者が自分で作成することはほぼない。 |
| オブジェクト型 | 下部構造を持つデータを表す。<br>データやそのデータに対する処理を内部的に持つことができる。 |

8つの型はオブジェクト型とそれ以外に分けられ、7つの非オブジェクト型（Null型、Undefined型、真偽値型、数値型、長整数型、文字列型、シンボル型）に属する値はまとめて **プリミティブ型** と呼ばれる。<br>
プリミティブは内部的な構造を持つことができない代わりに様々な演算子を使用した高速で効率的な操作が可能。

## 2.2 リテラル

ソースコード上で直接記述できる値はリテラル値と呼ばれ、プリミティブ値を表現するために利用できるのは下記の4種類。

| リテラル | データ型 | 代表的な値 |
| --- | --- | --- |
| Nullリテラル | Null型 | null |
| 真偽値リテラル | 真偽値型 | true, false |
| 数値リテラル | 数値型、長整数型 | 42.0、 42n、 0x2a など |
| 文字列リテラル | 文字列型 | "物質"、 '粒子'、 \`宇宙\` など |

## 2.3 定数

定数は下記のような構文で定義でき、設定された値の代わりに利用できる。

```javascript
const 定数名 = 値
```

### 2.3.1 識別子に利用できる文字

実用上は **1文字目にはアルファベットと$と_が利用可能で、2文字目以降には1文字目に利用できる文字手に加えて数字も利用可能** 。<br>
加えて、実は日本語の文字も利用できる。

### 2.3.2 識別子に利用できない語

プログラミング言語にとって意味のある単語を **トークン** と呼ぶが、トークンとして使用されている単語や、将来トークンとして使用される可能性がある単語は識別子として使用できない。

```
await      break      case       catch      class      const      continue
debugger   default    delete     do         else       export     extends 
finally    for        function   if         import     in         instanceof
new        return     super      switch     this       throw      try
typeof     var        void       while      with       yield      let
static     enum       implements package    protected  interface  private
public
```

これらの名前はシステムによってすでに予約されていて開発者は利用できないという意味で **予約語** と呼ばれる。

## 2.4 変数

定数は **具体的な値に名前を付けるもの** であるが、変数は値そのものではなく、その値の果たすべき **役割に名前を付ける** のだと考える。

### 2.4.1 変数を宣言する

変数は下記のような構文で定義できる。
また、初期化されていない値はundefinedとなる。

```javascript
let 変数名      // undefined
let 変数名 = 値
```

## 2.5 Undefined

**Undefined型** は未定義の値のための型である。<br>
この型に属する値はシステムに初めから用意されている `undefined` のみである。

変数の初期化が終わっているかを確認するために `undefined` と比較することはあるかもしれないが、それ以外の場所ではほとんど使うことはない。<br>
何か処理を行った結果が無効な値であることを示したい場合は `null` を使用する。

## 2.6 Null

**Null型** は無効なオブジェクトであることを示す。<br>
`undefined` は明示的に代入することはまずないが、 `null` は変数の内容が無効であることを示すために明示的に代入されることがある。

## 2.7 真偽値

**真偽値** は **ブーリアン** とも呼ばれ、真（true）と偽（false）という2つの値を表現するための型である。

## 2.9 長整数

**長整数** はJavaScriptで利用できるもうひとつの数値型である。<br>
通常の数値型とは異なり、表現できる数値が整数に限定される代わりに任意の大きさの数を表現できる。

## 2.10 文字列

**文字列** は文字の連なりを表すデータ型である。<br>
文字列は任意の文字の並びを **ダブルクォーテーション** または **シングルクォーテーション** で挟むことで作成する。

文字列中に両方のクォーテーションが出現する場合、一方のクォーテーションを使用すると他方が使用できない。<br>
この場合は **バックスラッシュ** を使用した **エスケープシーケンス** が利用可能である。

| エスケープシーケンス | 対応する文字 |
| --- | --- |
| \b | バックスペース |
| \t | 水平タブ |
| \n | 改行 |
| \v | 垂直タブ |
| \f | 改ページ |
| \r | キャリッジリターン |
| \" | " |
| \' | ' |
| \\ | \ |

## 2.11 テンプレート

文字列を生成するリテラルにはこれまでに紹介してきた文字列リテラルに加えてもうひとつ、 **テンプレートリテラル** がある。<br>
通常の文字列はダブルクォーテーションやシングルクォーテーションで作成するが、テンプレートリテラルは **バッククォート** を使用して作成する。

```javascript
`hogehoge`
```

テンプレートリテラルはその名のとおりテンプレートを作成するためのリテラルで、ここで言うテンプレートとは文章の雛形のことである。<br>
テンプレートリテラルと一般の文字列リテラルの違いは次の3つである。

- 文字列リテラル内の開業の扱い
- 変数などの埋め込み
- テンプレートリテラルのタグ付け

### 2.11.1 文字列に改行を含める

通常の文字列の場合、途中で改行すると構文エラーになるため改行を使用するには **エスケープシーケンス(\n)** をしようする必要があった。<br>
テンプレートリテラルはエスケープせずにそのまま改行を入力できる。

```javascript
const template = `Hello, Suzuki
My name is Tanaka.`;
console.log(template);
// Hello, Suzuki.
// My name is Tanaka.
```

### 2.11.2 文字列にJavaScriptの式を埋め込む

通常、テンプレート文字列はその一部をコンテキストに応じて置き換えるために使用する。<br>
テンプレートリテラル内で `${ ... }` という表現を使用することで変数の内容などをその部分に内挿できる。

```javascript
const from = 'Tanaka', to = 'Suzuki';
const template = `Hello, ${to}.
My name is ${from}`;
console.log(template);
// Hello, Suzuki.
// My name is Tanaka.
```

## 2.12 配列

配列やオブジェクトを使うことで複数のリテラルを組み合わせてひとつにまとめることができる。<br>
配列を使用すると複数のリテラルを順番にまとめて管理できる。<br>
また、必要に応じて指定した位置の要素を取り出して利用することができる。

### 2.12.1 配列を作成する

配列は配列リテラルを使用して作成できる。<br>
配列は **複数の関連する情報をひとつにまとめて名前をつけられる** ことが利点である。

```javascript
const days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
```

配列の各要素を展開して別の配列の要素として追加したい場合は **スプレッド構文(...)** を利用する。

```javascript
const arr1 = [1, 3, 5];
const arr2 = [2, 4, 6, ...arr1];
console.log(arr2);
// [2, 4, 6, 1, 3, 5]
```

### 2.12.2 配列の要素を取得する

配列の要素は **ブラケット記法** で取り出すことができる。

```javascript
const days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
console.log(days[0]);
console.log(days[1]);
console.log(days[-1]);
// 31
// 28
// undefined
```

#### 2.12.2.1 複数の要素をまとめて取得する

**分割代入** を使用すると、このような冗長な記述を避けられる。<br>

```javascript
const days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
[jan, feb, mar] = days;
console.log(jan);
console.log(feb);
console.log(mar);
// 31
// 28
// 31
```

### 2.12.3 配列の要素を設定する

配列では、要素は固定ではなく、ブラケット記法と代入演算子を組み合わせることで入れ替えたり新しく追加できる。

```javascript
let arr1 = ['a', 'b', 'c'];
arr1[0] = 'z';
arr1[3] = 'x';
console.log(arr1);
// ['z', 'b', 'c', 'x'];
```

## 2.13 オブジェクト

オブジェクトはリテラルをまとめるもうひとつの手段である。<br>
配列では要素を順番で管理していたが、オブジェクトではインデックスではなく名前で要素にアクセスできるようになり、より明確に意図を表現することができる。

### 2.13.1 オブジェクトを作成する

オブジェクトの要素は名前（キー）と値のペアである。<br>
オブジェクトリテラルを使用して生成する場合、名前と値をコロンで区切ったものを一つの要素として、それらをカンマで繋ぎ、全体を {} で囲む。<br>
また、オブジェクトのそれぞれの要素を **プロパティ** と呼び、プロパティの値は任意の型をとることができる。

```javascript
const obj = {
  name: 'Tanaka',
  age: 25,
}
```

また、オブジェクトの値に別のオブジェクトを展開して埋め込みたい場合hには、配列と同様にスプレッド構文が利用できる。

```javascript
const obj1 = {id: 1, name: 'Tanaka'};
const obj2 = {...obj1, age: 25};
console.log(obj2);
// {id: 1, name: "Tanaka", age: 25}
```

プロパティ名には `[]` で囲むことで動的に得られる文字列やシンボルも使用できる。<br>
これを **計算によるプロパティ名** と呼ぶ。

```javascript
const obj = {['project' + 'Id']: 1};
console.log(obj);
// {projectId: 1}
```

### 2.13.2 プロパティの値を取得する

オブジェクトから値を取り出す方法には **ドット記法** 、 **ブラケット記法** 、 **オプショナルチェーン演算子** がある。<br>
一般的にはプロパティ名が識別子として有効な文字列であればドット記法が使用される。

```javascript
const person = {name: 'Tanaka', age: 25};
// ドット記法
person.name;
// ブラケット記法
person['name'];
// オプショナルチェーン演算子
person?.name;
```

また、存在しないプロパティ名にアクセスするとundefinedが返され、undefinedに対してアクセスしてしまうとエラーが発生する。
オプショナルチェーン演算子はオブジェクトのnull/undefinedチェックを行、オブジェクトが存在する場合にだけプロパティアクセスを実行する。

```javascript
const person = {name: 'Tanaka', age: 25};
console.log(person.birthday.year);
// Uncaught TypeError: Cannot read property
console.log(person?.birthday?.year);
// undefined
```

### 2.13.3 プロパティの値をまとめて取得する

分割代入を使ってオブジェクトの複数のプロパティの値をまとめて取得して変数に格納できる。

```javascript
const person = {name: 'Tanaka', age: 25, birth_year: 1989, birth_month: 4, birth_day: 1};
// 取得したいプロパティ名: 格納する変数名
const {name: shimei, birth_year: umaredoshi} = person;
console.log(shimei);
console.log(umaredoshi);
// Tanaka
// 1989
```

### 2.13.4 複雑な構造のオブジェクトから値をまとめて取得する

分割代入は単純な配列やオブジェクトだけでなく、それらが入れ子になった複雑なオブジェクトに対しても利用できる。

```javascript
const person = {
  name: 'Tanaka',
  age: 25,
  skills: [
    {name: 'JavaScript', lank: 'C'},
    {name: 'PHP', lank: 'A'},
  ],
}
const {name: shimei, skills:[{lank: js_lank}, {lank: php_lank}]} = person;
console.log(shimei);
console.log(js_lank);
console.log(php_lank);
// Tanaka
// C
// A
```

### 2.13.5 プロパティに値を設定する

新たにプロパティを追加する場合や、既存のプロパティの値を書き換える場合にはドット記法またはブラケット記法と代入演算子を組み合わせる。

```javascript
const person = {name: 'Tanaka', age: 25};
person.age = person.age + 1;
person.birthday = '1989/04/01';
console.log(person);
// {name: 'Tanaka', age: 26, birthday: '1989/04/01'}
```

### 2.13.6 プロパティの有無を確認する

オブジェクトのプロパティの有無は **in演算子** で確認できる。

```javascript
const person = {name: 'Tanaka', age: 25};
console.log('birthday' in person);
// false
```

### 2.13.7 プロパティを削除する

オブジェクトのプロパティは **delete演算子** で削除できる。

```javascript
const person = {name: 'Tanaka', age: 25};
delete person.age;
// true
```

### 2.13.8 オブジェクトの同一性を比較する

値が等価かどうかは **等価演算子** を使用して確認できる。<br>
しかし配列やオブジェクトについては結果が想定と異なる動作になる場合があるが、<br>
「変数に格納されるのはオブジェクトや配列そのものではなく、メモリアドレスの参照」であることが理由である。

```javascript
const personA = {name: 'Tanaka', age: 25};
const personB = {name: 'Tanaka', age: 25};
// ※ プロパティや値が一致していていても等価ではないと判定される
console.log(personA === personB);
// false

// ※ オブジェクトを複製した場合は等価と判定される
const personC = personA;
console.log(personA === personC);
// true
```
